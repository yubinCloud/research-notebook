import{_ as c,r as a,o as s,c as i,a as e,b as t,d as o,w as r,e as d}from"./app-s5JIphqh.js";const m={},u={href:"https://aclanthology.org/N18-2093",target:"_blank",rel:"noopener noreferrer"},p=e("p",null,"⭐⭐⭐",-1),h=e("p",null,"NAACL 2018, arXiv:1804.09769",-1),g={href:"https://github.com/taoyds/typesql",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"一、论文速读",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、论文速读"},[e("span",null,"一、论文速读")])],-1),y=e("p",null,"本论文是在 SQLNet 网络上做的改进，其思路也是先预先构建一个 SQL sketch，然后再填充 slots 从而生成 SQL。",-1),b=e("p",null,[t("论文发现：在 question 中往往包含与特定数据相关的 rare entity 和 number，这对于在 SQL 查询中推断 column name 和 WHERE condition value 很重要，但这些 entity 和 number 缺乏准确的 embedding。为了解决这个问题，"),e("strong",null,"本工作为 question 的每个 word 分配了一个 type"),t('：知识图谱中的 entity、"COLUMN" 或者一个 number，如下图的最下面的 input 所示，为 question 的每个 word 都分配了一个 type：')],-1),L=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240523193915.png",alt:"20240523193915",style:{zoom:"75%"}},null,-1),k=d('<p><strong>具体来说</strong>，首先对 question 做分词，切分成长度为 2~6 的 n-grams，然后：</p><ul><li>使用 gram 检索数据库的 table schema，如果能检索到相应的 column name，那就将其 type 标注为 <code>COLUMN</code></li><li>为 number 和 date 标注为以下四个类别之一：<code>INTEGER</code>、<code>FLOAR</code>、<code>DARE</code>、<code>YEAR</code></li><li>为了识别命名实体，用 gram 作为 keyword 在 Freebase 上做检索五类实体：<code>PERSON</code>、<code>PLACE</code>、<code>COUNTRY</code>、<code>ORGANIZATION</code>、<code>SPORT</code>，并做相应的 type 标注，这五类实体已经可以覆盖了数据集中的绝大多数实体</li></ul><p>由此，我们才可以看到上图中对 question 的 type 标注结果。</p><p>拓展来开的话，如果 database 的内容也可以访问，那我们在做 type 标注时，还会将 gram 从 table schema、column content 和 column label 中做检索，并将 type 标注为具体的 column name。比如上图中，question 中的 <em>mort drucker</em> 可以被标注为 <em>artist</em>，因为我们能在数据库中检索到这个 gram 并发现对应的 column name 为 <em>artist</em>。</p><p>对 question 做完 type 标注后，在之后做编码时，就可以将 question 中的原 token 和对应的 type 一起做 embedding，并将两个 embedding 连接在一起做 encode 并进一步处理。</p><p>在之后填充 SQL sketch 做 slots 预测时，原来的 SQLNet 模型是为五种 slots 设计了五个 model 来分别训练和预测，而本文的 TypeSQL 将其中功能相似的 model 做了合并，最终只需要 3 个 model 来完成填充任务，架构上做了简化。具体公式可以参考原论文。</p><h2 id="二、总结" tabindex="-1"><a class="header-anchor" href="#二、总结"><span>二、总结</span></a></h2><p>这篇论文的工作主要是对 SQLNet 做的改进，改进主要有如下：</p><ul><li>借助于数据库的 table schema 检索和 knowledge graph 的检索，为 question 的每个 word 标注一个 type，从而提高 embedding 的效果</li><li>当 database content 可用时，type 标注时还会进一步对 column content 做检索，并为其标注 column name，这样当用户的 question 中的所提到的列名或者条目不精确时，也可以通过这个步骤来对应到具体的数据库 column，从而提高效果，实现所谓的“<strong>内容敏感性</strong>”。</li><li>改进了 SQLNet 的 slots 填充步骤，减少了所需要的 model 数量，架构上也做了简化</li></ul>',9);function S(N,f){const n=a("ExternalLinkIcon"),l=a("center");return s(),i("div",null,[e("blockquote",null,[e("p",null,[t("论文："),e("a",u,[t("TypeSQL: Knowledge-Based Type-Aware Neural Text-to-SQL Generation"),o(n)])]),p,h,e("p",null,[t("Code: "),e("a",g,[t("TypeSQL | GitHub"),o(n)])])]),_,y,b,o(l,null,{default:r(()=>[L]),_:1}),k])}const Q=c(m,[["render",S],["__file","index.html.vue"]]),x=JSON.parse(`{"path":"/arxiv/1804.09769/","title":"🐋 经典论文：TypeSQL","lang":"zh-CN","frontmatter":{"title":"🐋 经典论文：TypeSQL","author":"Bin Yu","createTime":"2024/05/23 19:25:00","permalink":"/arxiv/1804.09769/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"一、论文速读","slug":"一、论文速读","link":"#一、论文速读","children":[]},{"level":2,"title":"二、总结","slug":"二、总结","link":"#二、总结","children":[]}],"readingTime":{"minutes":2.59,"words":776},"git":{"updatedTime":1717830098000,"contributors":[{"name":"yubinCloud","email":"yubin_SkyWalker@yeah.net","commits":3}]},"filePathRelative":"notes/Text2SQL/1804.TypeSQL.md","categoryList":[{"type":10000,"name":"notes"},{"type":10004,"name":"Text2SQL"}]}`);export{Q as comp,x as data};
