import{_ as r,r as i,o as c,c as p,a as e,b as t,d as s,w as o,e as a}from"./app-s5JIphqh.js";const h={},m={href:"http://arxiv.org/abs/2403.09732",target:"_blank",rel:"noopener noreferrer"},d=e("p",null,"⭐⭐⭐",-1),u=e("p",null,"arXiv:2403.09732，商汤 & 北大",-1),L={href:"https://github.com/zhshLii/PETSQL",target:"_blank",rel:"noopener noreferrer"},g=a('<h2 id="一、论文速读" tabindex="-1"><a class="header-anchor" href="#一、论文速读"><span>一、论文速读</span></a></h2><p>论文一开始提出了以往 prompt-based 的 Text2SQL 方法的一些缺点：</p><ul><li>缺少对 table cell value 的先验关注。比如查询 sex 时，<code>WHERE sex=&#39;Male&#39;</code>、<code>WHERE sex=&#39;M&#39;</code> 都是有可能的，LLM 也拿不准用哪个</li><li>通过 prompt 让 LLM 做 schema linking 时，让 LLM 根据 question 和 schema 列出相关 schema 的效果并不好，因为像对于 CodeLlama 这样的模型来说，基于指令生成非代码文本并不是他们的强项</li><li>目前方法的 post-refinements 收益也不明显： <ul><li>如果一个由强大的 LLM 生成的 SQL 具有语义模糊而不是语法错误的话，那 LLM 是无法 self-debugging 的</li><li>使用 self-consistency 时，LLM 的投资和产出是不成比例，多次调用一个 LLM 产生数倍的成本，并没有从根本上让 SQL 的输出更加多样化</li></ul></li></ul><p>由此，论文提出了 <mark>Prompt-Enhanced Two-stage text2SQL framework with cross-consistency</mark>（<strong>PET-SQL</strong>）—— 通过两个 stage 来完成任务。</p><h2 id="二、pet-sql" tabindex="-1"><a class="header-anchor" href="#二、pet-sql"><span>二、PET-SQL</span></a></h2><h3 id="_2-1-stage-1-few-shots-prompt-生成-presql" tabindex="-1"><a class="header-anchor" href="#_2-1-stage-1-few-shots-prompt-生成-presql"><span>2.1 Stage 1：few-shots prompt 生成 PreSQL</span></a></h3><p>这个阶段构造出一个 few-shots 的 prompt 用来输入给 LLM。</p><h4 id="_2-1-1-prompt-的表示风格" tabindex="-1"><a class="header-anchor" href="#_2-1-1-prompt-的表示风格"><span>2.1.1 prompt 的表示风格</span></a></h4><p>有多种指导 LLM 生成 SQL 的 prompt 表示风格。以往研究发现，Code Representation（<strong>CRp</strong>）和 OpenAI Demonstration（<strong>ODp</strong>）这两种是很不错的选择，示例如下图：</p>',9),_=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240608142243.png",alt:"20240608142243",style:{zoom:"75%"}},null,-1),S=e("p",null,[t("论文基于 ODp 进一步丰富了 prompt 的信息，提出了 Reference-Enchanced representation（"),e("mark",null,"REp"),t("）的 prompt，改动如下：")],-1),f=e("ul",null,[e("li",null,[t("在 instruction 最后加了一句 "),e("code",null,"You must minimize SQL execution time while ensuring correctness"),t(" 来指示 LLM 不仅要关注执行正确性，还要注意 SQL 语句的效率，避免冗余的字符和操作符。")]),e("li",null,"prompt 中增加 table cell value 示例，也就是随机选择数据库表的 3 rows"),e("li",null,"prompt 中增加 schema 的外键关系")],-1),k=e("p",null,"提出的 REp 示例如下：",-1),Q=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240608142718.png",alt:"20240608142718",style:{zoom:"75%"}},null,-1),b=e("h4",{id:"_2-1-2-增加-few-shots-examples",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-1-2-增加-few-shots-examples"},[e("span",null,"2.1.2 增加 few-shots examples")])],-1),x=e("p",null,"这里从 dataset 中检索出与 user question 相似的样本来作为 ICL 的 demonstrations。",-1),y=e("p",null,[t("注意，这里要对被检索的 NL-SQL pairs 做"),e("strong",null,"去语义化"),t("：也就是把 question 中与 table schema 相关的 tokens 用 "),e("code",null,"<mask>"),t(" 去掉，从而得到一个只呈现问题意图的 question skeleton。然后再对这些 question skeleton 使用 embedding 做语义嵌入，从而用于检索。")],-1),M=e("p",null,"检索到的 top-K 被用作 demonstrations 用于 few-shots ICL。",-1),w=e("p",null,"这样，demonstrations 和前面的 REp prompt 结构，构成了用于输入给 LLM 的 prompt：",-1),q=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240608143537.png",alt:"20240608143537",style:{zoom:"75%"}},null,-1),E=e("p",null,[t("由此，可以得到一个 LLM 生成的 preliminary SQL（"),e("strong",null,"PreSQL"),t("）。")],-1),C=e("h3",{id:"_2-2-stage-2-schema-linking-与-finsql-生成",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-2-stage-2-schema-linking-与-finsql-生成"},[e("span",null,"2.2 Stage 2：Schema Linking 与 FinSQL 生成")])],-1),T=e("p",null,"这里的实现基于一个简单的原则：PreSQL 与 question 高度相关。",-1),v=e("p",null,"因此，解析 PreSQL 以识别其中提到的 db tables 和 columns，并用于数据库的 schema linking。",-1),P=e("p",null,"然后 schema linking 的结果被用来简化 prompt 中的 schema 信息，去除掉无关的 table 和 column 信息，如下所示：",-1),R=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240608144734.png",alt:"20240608144734",style:{zoom:"75%"}},null,-1),z=a('<p>使用这个简化后的 prompt 用来生成 FinSQL。</p><h3 id="_2-3-cross-consistency" tabindex="-1"><a class="header-anchor" href="#_2-3-cross-consistency"><span>2.3 Cross Consistency</span></a></h3><p>以往做 Text2SQL 时往往会使用 self-consistency 来修正 SQL 结果，但这有一些问题：使用 self-consistency 往往是将 LLM 的问题调高使其生成多样化，然后多次生成后投票选出最终结果。但是研究也发现，高温下的 LLM 会增加幻觉、降低性能，且对于确定性任务（如生成 SQL），单个 LLM 的多样性也不足。</p><p>所以本文提出：<strong>在较低的温度下指导多个 LLMs 生成 SQL，然后在这些 SQL 的执行结果之间投票</strong>。这也就是 <mark>Cross Consistency</mark>。</p><p>关于投票的思路，这里提出了两种：</p><ul><li><strong>Naive voting</strong>：让每个 LLMs 都生成一个 SQL，执行后进行投票，将大多数结果作为最终答案</li><li><strong>Fine-grained voting</strong>：由于不同的 LLM 的能力不同，所能处理的问题的复杂度不同，因此，根据 PreSQL 的语法解析结果将 question 分为四个难度，然后不同的难度的问题由不同的候选 LLMs 来解决，并进行投票。这样可以最大限度发挥 LLM 的潜力，并显著减轻投票偏见。</li></ul><h2 id="三、实验" tabindex="-1"><a class="header-anchor" href="#三、实验"><span>三、实验</span></a></h2><p>在 Spider 数据集上做了测试，使用 EX 作为评估，使用的 LLM 包括 CodeLlama、SQLCode、IternLM、SenseChat、GPT-4 等。</p><p>在 Spider 上的表现，在所有非基于学习的方法中实现了最高的 EX，比 DAIL-SQL 高出 1%。</p><p>具体的实现可以参考原论文。</p><h2 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h2><p>PET-SQL 的两阶段思路还是挺好理解上，prompt 设计上主要多了 db content 样例，整个过程中，使用 question de-semanticization 来提取问题骨架表示问题意图在实现上应该是整个流程里最复杂的。</p>',12);function I(N,F){const l=i("ExternalLinkIcon"),n=i("center");return c(),p("div",null,[e("blockquote",null,[e("p",null,[t("论文："),e("a",m,[t("PET-SQL: A Prompt-enhanced Two-stage Text-to-SQL Framework with Cross-consistency"),s(l)])]),d,u,e("p",null,[t("Code："),e("a",L,[t("GitHub"),s(l)])])]),g,s(n,null,{default:o(()=>[_]),_:1}),S,f,k,s(n,null,{default:o(()=>[Q]),_:1}),b,x,y,M,w,s(n,null,{default:o(()=>[q]),_:1}),E,C,T,v,P,s(n,null,{default:o(()=>[R]),_:1}),z])}const B=r(h,[["render",I],["__file","index.html.vue"]]),D=JSON.parse(`{"path":"/arxiv/2403.09732/","title":"💦 PET-SQL：用 Cross-Consistency 的 prompt 增强的两阶段 Text2SQL 框架","lang":"zh-CN","frontmatter":{"title":"💦 PET-SQL：用 Cross-Consistency 的 prompt 增强的两阶段 Text2SQL 框架","author":"Bin Yu","createTime":"2024/06/07 21:41:00","permalink":"/arxiv/2403.09732/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"一、论文速读","slug":"一、论文速读","link":"#一、论文速读","children":[]},{"level":2,"title":"二、PET-SQL","slug":"二、pet-sql","link":"#二、pet-sql","children":[{"level":3,"title":"2.1 Stage 1：few-shots prompt 生成 PreSQL","slug":"_2-1-stage-1-few-shots-prompt-生成-presql","link":"#_2-1-stage-1-few-shots-prompt-生成-presql","children":[]},{"level":3,"title":"2.2 Stage 2：Schema Linking 与 FinSQL 生成","slug":"_2-2-stage-2-schema-linking-与-finsql-生成","link":"#_2-2-stage-2-schema-linking-与-finsql-生成","children":[]},{"level":3,"title":"2.3 Cross Consistency","slug":"_2-3-cross-consistency","link":"#_2-3-cross-consistency","children":[]}]},{"level":2,"title":"三、实验","slug":"三、实验","link":"#三、实验","children":[]},{"level":2,"title":"四、总结","slug":"四、总结","link":"#四、总结","children":[]}],"readingTime":{"minutes":4.19,"words":1256},"git":{"updatedTime":1717830098000,"contributors":[{"name":"yubinCloud","email":"yubin_SkyWalker@yeah.net","commits":1}]},"filePathRelative":"notes/Text2SQL/2403.PET-SQL.md","categoryList":[{"type":10000,"name":"notes"},{"type":10004,"name":"Text2SQL"}]}`);export{B as comp,D as data};
