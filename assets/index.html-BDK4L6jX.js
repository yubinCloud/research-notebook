import{_ as i,r as l,o as s,c,a as e,b as t,d as o,w as a,e as u}from"./app-s5JIphqh.js";const d={},h={href:"https://towardsdatascience.com/routing-in-rag-driven-applications-a685460a7220",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,'根据用户的查询意图，在 RAG 程序内部使用 "Routing the control flow" 可以帮助我们构建更实用强大的 RAG 程序。路由模块的关键实现就是一个 Router，它根据 user query 的查询意图，来将该请求的处理转发到多个下游 handlers 之一。',-1),p=e("h2",{id:"_1-不同的应用场景",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-不同的应用场景"},[e("span",null,"1. 不同的应用场景")])],-1),m=e("h3",{id:"_1-1-路由到-data-source",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-1-路由到-data-source"},[e("span",null,"1.1 路由到 data source")])],-1),g=e("p",null,"用户想进行交互的数据可能有多种来源，Query Router 可以用于根据 user query 路由到不同的 data source：",-1),f=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240511194228.png",alt:"20240511194228",style:{zoom:"75%"}},null,-1),k=e("h3",{id:"_1-2-路由到不同的-component",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-2-路由到不同的-component"},[e("span",null,"1.2 路由到不同的 component")])],-1),b=e("p",null,"还可以根据问题的性质，将 query 路由到不同的组件类型，比如可能交给 Agent 处理、Vector Store 处理或者直接由 LLM 处理：",-1),L=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240511194735.png",alt:"20240511194735",style:{zoom:"75%"}},null,-1),R=e("h3",{id:"_1-3-路由到不同的-prompt-template",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-3-路由到不同的-prompt-template"},[e("span",null,"1.3 路由到不同的 prompt template")])],-1),y=e("p",null,"可以根据 question 的不同来定制 prompt template：",-1),x=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240511194845.png",alt:"20240511194845",style:{zoom:"75%"}},null,-1),v=u('<h3 id="_1-4-小结" tabindex="-1"><a class="header-anchor" href="#_1-4-小结"><span>1.4 小结</span></a></h3><p>Router 在本质上就是我们可以用于控制 query control flow 的 &quot;if / else&quot; 语句，不过它的特点在于是<strong>基于自然语言输入来做出决策</strong>。</p><p>很多 routing 的逻辑都是基于 LLM 或者 ML 算法，这些算法本质上是非确定性的，所以我们无法保证 router 总是能做出 100% 正确的选择。此外，我们也不太可能预测所有进入路由器的不同查询变体。但是，通过采用最佳实践和进行一些测试，我们可以使用路由器来帮助创建更强大的 RAG 应用程序。</p><h2 id="_2-natural-language-routers" tabindex="-1"><a class="header-anchor" href="#_2-natural-language-routers"><span>2. Natural Language Routers</span></a></h2><p>这里探讨一下由不同的第三方库所实现的 Natural Language Router：</p><ul><li>LLM Completion Routers</li><li>LLM Function Calling Routers</li><li>Semantic Routers</li><li>Zero Shot Classification Routers</li><li>Language Classification Routers</li></ul><h3 id="_2-1-llm-completion-router" tabindex="-1"><a class="header-anchor" href="#_2-1-llm-completion-router"><span>2.1 LLM Completion Router</span></a></h3><p>利用 LLM 的 Chat Completion 的功能，以对话的形式要求 LLM 从 prompt 中提供的一组单词或 topics 中选择一个来作为 routing 的结果。如下图的示例程序所示：</p><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/1715431892457.jpg" alt="1715431892457" style="zoom:80%;"><p>这种思路也是 LlamaIndex 的 LLM Selector router 的工作思路。</p><h3 id="_2-2-llm-function-calling-router" tabindex="-1"><a class="header-anchor" href="#_2-2-llm-function-calling-router"><span>2.2 LLM Function Calling Router</span></a></h3><p>这种方法利用 LLM 的 Function Calling 能力来选择 routing 的路线结果。在 LLM 函数调用中，将不同的 routing 路线设置为具有相应描述的函数，然后，根据向 LLM 传递的 query，它能够返回正确的函数（即路线）供我们使用。</p>',12),q={href:"https://docs.llamaindex.ai/en/stable/module_guides/querying/router/",target:"_blank",rel:"noopener noreferrer"},C=e("h3",{id:"_2-3-semantic-router",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-3-semantic-router"},[e("span",null,"2.3 Semantic Router")])],-1),w=e("p",null,"这种路由器类型利用嵌入式表示和相似度搜索来选择最佳的 routing 方式。",-1),M=e("p",null,"每条路由都有一组与其相关联的示例查询，这些查询会做 embedding 并作为 vector 存储。将新来的 query 也进行 embedding，然后对其他来自 router 中的示例查询进行相似性搜索，与 query 匹配度最相近的 routing 路线将被选中。",-1),A={href:"https://github.com/aurelio-labs/semantic-router",target:"_blank",rel:"noopener noreferrer"},z=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/1715434301179.png",alt:"1715434301179",style:{zoom:"90%"}},null,-1),S=e("p",null,"embedding 模型可以选择 OpenAI 提供的 encoder，其实也可以选用其他的 text embedding 模型。",-1),G=e("p",null,"由此，对于一个 user query，semantic_router 就可以将其分为 politics 或者 chitchat 两者之一的 routing 结果。",-1),N=e("h3",{id:"_2-4-zero-shot-classification-router",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-4-zero-shot-classification-router"},[e("span",null,"2.4 Zero Shot Classification Router")])],-1),T={href:"https://huggingface.co/tasks/zero-shot-classification",target:"_blank",rel:"noopener noreferrer"},I=e("p",null,"在这里，我们的 router 可以利用 zero-shot classification 的 model 为一段 text 分配一个 label，这个 label 是 router 预先定义的标签集。",-1),P={href:"https://docs.haystack.deepset.ai/reference/routers-api#module-zero_shot_text_router",target:"_blank",rel:"noopener noreferrer"},j=e("h3",{id:"_2-5-language-classification-router",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-5-language-classification-router"},[e("span",null,"2.5 Language Classification Router")])],-1),F=e("p",null,"这类 router 可以识别出查询语言的语言种类，并根据语言种类对 query 进行路由。如果您的应用程序需要多语言解析能力，那么这种路由器就非常有用。",-1),B={href:"https://docs.haystack.deepset.ai/reference/routers-api#module-text_language_router",target:"_blank",rel:"noopener noreferrer"},E=e("h3",{id:"_2-6-keyword-router",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-6-keyword-router"},[e("span",null,"2.6 Keyword Router")])],-1),V={href:"https://betterprogramming.pub/unifying-llm-powered-qa-techniques-with-routing-abstractions-438e2499a0d0",target:"_blank",rel:"noopener noreferrer"},Z=e("p",null,"这种关键词路由器可以由LLM（语言模型）或其他关键词匹配库来识别关键词。目前未找到相关实现。",-1),H=e("h3",{id:"_2-7-logical-routers",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-7-logical-routers"},[e("span",null,"2.7 Logical Routers")])],-1),K=e("p",null,"这些逻辑检查会针对变量进行，比如字符串长度、文件名以及值的比较等，用于处理如何路由查询。它们与编程中常用的 if/else 条件非常相似。",-1),O=e("p",null,"换句话说，它们不是基于理解自然语言查询的意图，而是基于现有的、离散的变量来做出选择。",-1),Q=e("p",null,"比如来自 Haystack 的 ConditionalRouter 和 FileTypeRouter。",-1),D=e("h2",{id:"_3-结论",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-结论"},[e("span",null,"3. 结论")])],-1),J=e("p",null,"router 作为基本的构建块，在 RAG 系统中可以发挥很大的作用，它可以将自然语言请求路由到你的应用程序的正确位置，以便尽可能地满足用户的查询需求。",-1);function U(W,Y){const n=l("ExternalLinkIcon"),r=l("center");return s(),c("div",null,[e("blockquote",null,[e("p",null,[t("Blog："),e("a",h,[t("Routing in RAG-Driven Applications"),o(n)]),t(" ⭐⭐⭐⭐")])]),_,p,m,g,o(r,null,{default:a(()=>[f]),_:1}),k,b,o(r,null,{default:a(()=>[L]),_:1}),R,y,o(r,null,{default:a(()=>[x]),_:1}),v,e("p",null,[t("这是 LlamaIndex 中的 "),e("a",q,[t("Pydantic Router"),o(n)]),t(" 的内部工作方式。")]),C,w,M,e("p",null,[t("Python 库 "),e("a",A,[t("semantic-router"),o(n)]),t(" 就实现了这一点，下图是官网的示例：")]),z,S,G,N,e("p",null,[e("a",T,[t("Zero Shot Classification"),o(n)]),t(" 是 NLP 的一类 task，其中 model 在一组 labeled data 上训练后，能够对来自以前未见过的类的新示例进行分类。")]),I,e("p",null,[t("Haystack 的 "),e("a",P,[t("ZeroShotTextRouter"),o(n)]),t(" 就是利用的 Hugging Face 的 zero shot 分类模型来实现的 routing。")]),j,F,e("p",null,[t("比如 Haystack 的 "),e("a",B,[t("TextClassificationRouter"),o(n)]),t(" 就是利用了 python 的 langdetect 库实现的检索文本的语言，该库本身使用朴素贝叶斯算法来检测语言种类。")]),E,e("p",null,[t("LlamaIndex 创始人的文章 "),e("a",V,[t("Unifying LLM-powered QA Techniques with Routing Abstractions"),o(n)]),t(" 中就提到了 keyword router，它会尝试通过在查询和路由列表之间匹配关键字来选择路由。")]),Z,H,K,O,Q,D,J])}const $=i(d,[["render",U],["__file","index.html.vue"]]),ee=JSON.parse(`{"path":"/medium/a685460a7220/","title":"🌮 RAG 应用中的 Routing","lang":"zh-CN","frontmatter":{"title":"🌮 RAG 应用中的 Routing","permalink":"/medium/a685460a7220/","author":"Bin Yu","createTime":"2024/05/11 19:38:00","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"1. 不同的应用场景","slug":"_1-不同的应用场景","link":"#_1-不同的应用场景","children":[{"level":3,"title":"1.1 路由到 data source","slug":"_1-1-路由到-data-source","link":"#_1-1-路由到-data-source","children":[]},{"level":3,"title":"1.2 路由到不同的 component","slug":"_1-2-路由到不同的-component","link":"#_1-2-路由到不同的-component","children":[]},{"level":3,"title":"1.3 路由到不同的 prompt template","slug":"_1-3-路由到不同的-prompt-template","link":"#_1-3-路由到不同的-prompt-template","children":[]},{"level":3,"title":"1.4 小结","slug":"_1-4-小结","link":"#_1-4-小结","children":[]}]},{"level":2,"title":"2. Natural Language Routers","slug":"_2-natural-language-routers","link":"#_2-natural-language-routers","children":[{"level":3,"title":"2.1 LLM Completion Router","slug":"_2-1-llm-completion-router","link":"#_2-1-llm-completion-router","children":[]},{"level":3,"title":"2.2 LLM Function Calling Router","slug":"_2-2-llm-function-calling-router","link":"#_2-2-llm-function-calling-router","children":[]},{"level":3,"title":"2.3 Semantic Router","slug":"_2-3-semantic-router","link":"#_2-3-semantic-router","children":[]},{"level":3,"title":"2.4 Zero Shot Classification Router","slug":"_2-4-zero-shot-classification-router","link":"#_2-4-zero-shot-classification-router","children":[]},{"level":3,"title":"2.5 Language Classification Router","slug":"_2-5-language-classification-router","link":"#_2-5-language-classification-router","children":[]},{"level":3,"title":"2.6 Keyword Router","slug":"_2-6-keyword-router","link":"#_2-6-keyword-router","children":[]},{"level":3,"title":"2.7 Logical Routers","slug":"_2-7-logical-routers","link":"#_2-7-logical-routers","children":[]}]},{"level":2,"title":"3. 结论","slug":"_3-结论","link":"#_3-结论","children":[]}],"readingTime":{"minutes":4.52,"words":1357},"git":{"updatedTime":1716026122000,"contributors":[{"name":"yubinCloud","email":"yubin_SkyWalker@yeah.net","commits":2}]},"filePathRelative":"notes/RAG/2405.RAG 应用中的 Routing.md","categoryList":[{"type":10000,"name":"notes"},{"type":10003,"name":"RAG"}]}`);export{$ as comp,ee as data};
