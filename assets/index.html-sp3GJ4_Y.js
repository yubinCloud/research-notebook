import{_ as c,r as o,o as r,c as h,a as e,b as s,d as a,w as n,e as l}from"./app-s5JIphqh.js";const m={},p={href:"http://arxiv.org/abs/2312.03463",target:"_blank",rel:"noopener noreferrer"},u=e("p",null,"⭐⭐⭐⭐",-1),g={href:"https://github.com/tshu-w/DBCopilot",target:"_blank",rel:"noopener noreferrer"},d=l('<h2 id="一、论文速读" tabindex="-1"><a class="header-anchor" href="#一、论文速读"><span>一、论文速读</span></a></h2><p>论文认为目前的 Text2SQL 研究大多只关注具有少量 table 的单个数据库上的查询，但在面对大规模数据库和数据仓库的查询时时却力显不足。本文提出的 DBCopilot 能够在大规模数据库上查询模式不可知的 NL question。</p><p>论文指出，实现这个的核心是：从能够构建各种 NL question 到海量数据库模型元素的 semantic mapping，从而能够自动识别目标数据库并过滤出最少的相关 tables。但目前的基于 LLM 的方法有两个主要挑战：</p><ul><li>由于 token 限制，无法将所有 schema 都输入给 LLM</li><li>LLM 仍然难以有效利用长上下文中的信息</li></ul><p>而在解决可扩展性的问题时，主要有基于 retrieval 的方法和基于 fine-tune 的方法，但是，</p><ul><li>基于 retrieval 的方法往往是将 doc 视为检索对象，忽略了 DB 和 DB table 之间的关系；</li><li>fine-tune LLM 来为其注入 schema 的相关知识是资源密集型的方式，且有时候 LLM 是无法微调的</li></ul><p>DBCopilot 的做法如下图所示：</p>',7),_=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240601213620.png",alt:"20240601213620",style:{zoom:"75%"}},null,-1),L=l('<p>主要分成两步：</p><ol><li><strong>Schema Routing</strong>：输入 user question，使用 DSI 技术找到所需要用的 DB 和 DB tables，也就是 DB schema。</li><li><strong>SQL Generation</strong>：输入 user question、DB schema，通过 prompt LLM 生成 SQL query。</li></ol><h2 id="二、问题定义" tabindex="-1"><a class="header-anchor" href="#二、问题定义"><span>二、问题定义</span></a></h2><h3 id="_2-1-schema-agnostic-nl2sql" tabindex="-1"><a class="header-anchor" href="#_2-1-schema-agnostic-nl2sql"><span>2.1 Schema-Agnostic NL2SQL</span></a></h3><p><mark>Schema-Agnostic NL2SQL</mark> 指的是：只给定 user question 而不给定预期的 SQL query schema（DB 和 DB tables），来生成一个可以在一个数据库集合中的某个 DB 上执行的 SQL。</p><blockquote><p>像之前 WikiSQL 数据集上，都是指定 question 在哪个 DB 上的。</p></blockquote><h3 id="_2-2-schema-linking-vs-schema-routing" tabindex="-1"><a class="header-anchor" href="#_2-2-schema-linking-vs-schema-routing"><span>2.2 Schema Linking VS. Schema Routing</span></a></h3><p>在以往的 NL2SQL 中，<strong>Schema Linking</strong> 的 input 是 question 和 schema，用于寻找 NL question 中提及到的 schema 元素（比如 tables、columns 或者 database value），可以被视作是一个 NL question 和 DB elements 之间的桥梁。</p><p><strong>Schema Routing</strong> 的 input 只有不知道 schema 的 question，它的输出是一个 indexed or memorized schema。</p><h2 id="三、方法" tabindex="-1"><a class="header-anchor" href="#三、方法"><span>三、方法</span></a></h2><h3 id="_3-1-schema-routing" tabindex="-1"><a class="header-anchor" href="#_3-1-schema-routing"><span>3.1 Schema Routing</span></a></h3><p>本文使用一个轻量级的 seq2seq 模型来作为 router，实现将 NL 识别出对应的 DB schema。</p><p>由于 space schema 很大（是 table 和 column 的笛卡尔积）、且 DB schema 可以发生变化，因此<strong>本文提出了一个 relation-aware、end-to-end joint retrieval 方法来解决 schema routing 问题</strong>。</p><p>具体做法是，先为 databases 构建一个 schema graph，然后设计一个 schema 序列化算法来将一个 schema 转化为 token-sequence，利用 graph-based contrained decoding 解码算法来让 seq2seq 模型生成 routing 的结果 DB schema。</p><h4 id="_3-1-1-schema-graph" tabindex="-1"><a class="header-anchor" href="#_3-1-1-schema-graph"><span>3.1.1 Schema Graph</span></a></h4><p>schema graph 包含了 databases 的 schema 信息，这个 graph 的 nodes 包含三类：</p>',16),b=e("ul",null,[e("li",null,[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("msub",null,[e("mi",null,"v"),e("mi",null,"s")])]),e("annotation",{encoding:"application/x-tex"},"v_s")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.5806em","vertical-align":"-0.15em"}}),e("span",{class:"mord"},[e("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t vlist-t2"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.1514em"}},[e("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mathnormal mtight"},"s")])])]),e("span",{class:"vlist-s"},"​")]),e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.15em"}},[e("span")])])])])])])])]),s("：一个特殊节点，指代含有所有 databases 的集合")]),e("li",null,"database"),e("li",null,"DB table")],-1),k=l('<p>graph 的 edge 包含两类：</p><ul><li><em>Inclusion relation</em>：表示一个 db 是否是一个 db collection 的一部分；或者一个 table 是否属于一个 db</li><li><em>Table relation</em>：包含显式的 PRIMARY-FOREIGN 关系和隐式的 FOREIGN-FOREIGN 关系</li></ul><blockquote><p>隐式的 FOREIGN-FOREIGN 关系指的是：A 表和 B 表的某个 column 共同连接到另一个 C 表的 key</p></blockquote><p>由此，任何有效的 SQL query schema 都是这个 schema graph 上的一个 trail（或者叫一个 path）。</p><h4 id="_3-1-2-schema-serialization" tabindex="-1"><a class="header-anchor" href="#_3-1-2-schema-serialization"><span>3.1.2 Schema Serialization</span></a></h4><p>这个序列化算法将一个 SQL query schema 序列化为一个 token seq，当然也可以将一个 token seq 解码出一个 DB schema。</p><p>具体的做法可以参考原论文，这里主要是基于 DFS（深度优先遍历）的思想。</p><p>有了这个序列化算法，当我们训练 seq2seq 的 schema router 模型时，由于需要监督它的 training data 是 (NL question, DB schema) pair，其中的 DB schema 就是序列化了的 schema。另外，router 的输出是一个 token seq，也需要反序列化将其转为结构化的 DB schema。</p><h4 id="_3-1-3-graph-based-的解码算法" tabindex="-1"><a class="header-anchor" href="#_3-1-3-graph-based-的解码算法"><span>3.1.3 graph-based 的解码算法</span></a></h4><p>在让 schema router 生成 token seq 时，为保证其生成的 schema 的有效性，每一个自回归生成的 step 中，都受到一个动态前缀树的约束，这个 tree 包含了解码后 schema 元素的可能访问节点的名称，如下图所示：</p>',10),S=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240602121044.png",alt:"20240602121044",style:{zoom:"75%"}},null,-1),v=e("p",null,"这样，每个生成 step 的可用 tokens 都可以通过搜索前缀树来获得，前缀就是在最后一个元素分隔符之后生成的 token。同时这里使用 diverse beam search 来生成多个候选序列。",-1),q=e("h4",{id:"_3-1-4-schema-router-的训练和推理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-1-4-schema-router-的训练和推理"},[e("span",null,"3.1.4 schema router 的训练和推理")])],-1),y=e("p",null,[s("我们需要使用 (NL question, DB schema) 这样的 pairs 来作为 training data 来训练 router，但是目前缺少这样的训练资料。所以，本文提出了使用一个"),e("mark",null,"训练数据合成方法"),s("来生成 question-schema pairs。")],-1),f=e("p",null,"这个训练数据合成方法具体来说就是：茨贝格 schema graph 中采样出一批合法的 schema，然后对每一个 schem 生成一个 pseudo-question，如下图所示：",-1),x=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240602121751.png",alt:"20240602121751",style:{zoom:"75%"}},null,-1),B=e("p",null,"具体的这个模型的训练可以参考原论文。",-1),N=e("p",null,[e("strong",null,"由此就可以得到用于训练 schema router 的 question-schema pairs"),s("。")],-1),D=e("p",null,[s("之后，我们就可以训练 Schema Router 了。训练数据集是 "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mo",{stretchy:"false"},"{"),e("mo",{stretchy:"false"},"("),e("msub",null,[e("mi",null,"N"),e("mi",null,"i")]),e("mo",{separator:"true"},","),e("msub",null,[e("mi",null,"S"),e("mi",null,"i")]),e("mo",{stretchy:"false"},")"),e("mo",{stretchy:"false"},"}")]),e("annotation",{encoding:"application/x-tex"},"\\{(N_i, S_i)\\}")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mopen"},"{("),e("span",{class:"mord"},[e("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t vlist-t2"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.3117em"}},[e("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mathnormal mtight"},"i")])])]),e("span",{class:"vlist-s"},"​")]),e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.15em"}},[e("span")])])])])]),e("span",{class:"mpunct"},","),e("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),e("span",{class:"mord"},[e("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t vlist-t2"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.3117em"}},[e("span",{style:{top:"-2.55em","margin-left":"-0.0576em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mathnormal mtight"},"i")])])]),e("span",{class:"vlist-s"},"​")]),e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.15em"}},[e("span")])])])])]),e("span",{class:"mclose"},")}")])])]),s("，也就是 quetsion-schema pairs，模型的训练损失函数如下：")],-1),M=e("img",{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20240602122049.png",alt:"20240602122049",style:{zoom:"75%"}},null,-1),Q=l('<p>训练出来之后，就可以使用 graph-based 的解码算法来做推理了。</p><h3 id="_3-2-sql-generation" tabindex="-1"><a class="header-anchor" href="#_3-2-sql-generation"><span>3.2 SQL Generation</span></a></h3><p>通过将 NL2SQL 任务解耦为 schema routing 和 SQL generation 两个部分，DB Copilot 可以与现在的 LLM-advanced NL2SQL 的解决方案进行融合，无论是 in-context prompt engineering 方法或者特定的 NL2SQL LLM。</p><p>前面的 schema router 可以为 NL 生成来自多个 db 的多个 schemas，这里探索了 3 种 prompt 策略来为 LLM 选择和合并这些不同的 DB schema：</p><ol><li><strong>Best Schema Prompting</strong>：从 schema router 种选择生成的最高概率的 schema 来 instruct LLM <ul><li>实验发现这种方式是最优的</li></ul></li><li><strong>Multiple Schema Prompting</strong>：将 beam search 得到的多个 table schemas 简单连接起来一起用来 instruct LLM。</li><li><strong>Multiple Schema COT Prompting</strong>：使用多个 candidate schemas 通过 COT 来 instruct LLM</li></ol><h2 id="四、实验" tabindex="-1"><a class="header-anchor" href="#四、实验"><span>四、实验</span></a></h2><p>论文在 Spider、Bird、Fiben 数据集上对 schema retrieval 和 NL2SQL 两个任务上进行实验对比，DBCopilot 有不错的表现。</p><blockquote><p>这里 NL2SQL 任务并没有与其他 SOTA 模型做实验对比</p></blockquote><h2 id="五、总结" tabindex="-1"><a class="header-anchor" href="#五、总结"><span>五、总结</span></a></h2><p>本文提出了 DBCopilot 模型，给出了一种将 NL 查询扩展到大规模数据库的思路，通过 LLM 协作来解决模式无关的 NL2SQL 任务。</p><p>总之，DBCopilot 突破了 NL2SQL 的界限，使得研究人员能够更好地执行数据可访问性的策略。</p>',11);function C(w,z){const i=o("ExternalLinkIcon"),t=o("center");return r(),h("div",null,[e("blockquote",null,[e("p",null,[s("论文："),e("a",p,[s("DBCopilot: Scaling Natural Language Querying to Massive Databases"),a(i)])]),u,e("p",null,[s("Code: "),e("a",g,[s("DBCopilot | GitHub"),a(i)])])]),d,a(t,null,{default:n(()=>[_]),_:1}),L,b,k,a(t,null,{default:n(()=>[S]),_:1}),v,q,y,f,a(t,null,{default:n(()=>[x]),_:1}),B,N,D,a(t,null,{default:n(()=>[M]),_:1}),Q])}const I=c(m,[["render",C],["__file","index.html.vue"]]),T=JSON.parse(`{"path":"/arxiv/2312.03463/","title":"🌙 DBCopilot：将 NL 查询扩展到大规模数据库","lang":"zh-CN","frontmatter":{"title":"🌙 DBCopilot：将 NL 查询扩展到大规模数据库","author":"Bin Yu","createTime":"2024/06/01 21:19:00","permalink":"/arxiv/2312.03463/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"一、论文速读","slug":"一、论文速读","link":"#一、论文速读","children":[]},{"level":2,"title":"二、问题定义","slug":"二、问题定义","link":"#二、问题定义","children":[{"level":3,"title":"2.1 Schema-Agnostic NL2SQL","slug":"_2-1-schema-agnostic-nl2sql","link":"#_2-1-schema-agnostic-nl2sql","children":[]},{"level":3,"title":"2.2 Schema Linking VS. Schema Routing","slug":"_2-2-schema-linking-vs-schema-routing","link":"#_2-2-schema-linking-vs-schema-routing","children":[]}]},{"level":2,"title":"三、方法","slug":"三、方法","link":"#三、方法","children":[{"level":3,"title":"3.1 Schema Routing","slug":"_3-1-schema-routing","link":"#_3-1-schema-routing","children":[]},{"level":3,"title":"3.2 SQL Generation","slug":"_3-2-sql-generation","link":"#_3-2-sql-generation","children":[]}]},{"level":2,"title":"四、实验","slug":"四、实验","link":"#四、实验","children":[]},{"level":2,"title":"五、总结","slug":"五、总结","link":"#五、总结","children":[]}],"readingTime":{"minutes":5.76,"words":1727},"git":{"updatedTime":1717830098000,"contributors":[{"name":"yubinCloud","email":"yubin_SkyWalker@yeah.net","commits":2}]},"filePathRelative":"notes/Text2SQL/2312.DBCopilot.md","categoryList":[{"type":10000,"name":"notes"},{"type":10004,"name":"Text2SQL"}]}`);export{I as comp,T as data};
